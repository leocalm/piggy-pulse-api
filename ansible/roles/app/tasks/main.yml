---
- name: Ensure PiggyPulse root directory exists
  ansible.builtin.file:
    path: "{{ piggypulse_project_root }}"
    state: directory
    owner: "{{ security_deploy_user }}"
    group: "{{ security_deploy_group }}"
    mode: "0750"

- name: Validate app deploy mode
  ansible.builtin.assert:
    that:
      - (piggypulse_deploy_mode | default('image_only')) in ['repo', 'image_only']
    fail_msg: >-
      Invalid piggypulse_deploy_mode='{{ piggypulse_deploy_mode | default("image_only") }}'.
      Supported values: repo, image_only.

- name: Ensure production compose directory exists
  ansible.builtin.file:
    path: "{{ piggypulse_compose_dir }}"
    state: directory
    owner: "{{ security_deploy_user }}"
    group: "{{ security_deploy_group }}"
    mode: "0750"
  when: (piggypulse_deploy_mode | default('image_only')) == 'image_only'

- name: Ensure repository credentials are configured when required
  ansible.builtin.assert:
    that:
      - (vault_piggypulse_repo_token | default('') | length) > 0
      - (vault_piggypulse_repo_username | default('') | length) > 0
    fail_msg: >-
      Repository authentication is required. Set vault_piggypulse_repo_username and
      vault_piggypulse_repo_token in ansible vault.
  when:
    - (piggypulse_deploy_mode | default('image_only')) == 'repo'
    - piggypulse_repo_requires_auth | default(false)

- name: Install temporary git askpass helper for private repository auth
  ansible.builtin.copy:
    dest: "/home/{{ security_deploy_user }}/.git-askpass.sh"
    owner: "{{ security_deploy_user }}"
    group: "{{ security_deploy_group }}"
    mode: "0700"
    content: |
      #!/usr/bin/env sh
      case "$1" in
        *sername*) printf '%s' "$GIT_USERNAME" ;;
        *assword*) printf '%s' "$GIT_PASSWORD" ;;
        *) printf '' ;;
      esac
  when:
    - (piggypulse_deploy_mode | default('image_only')) == 'repo'
    - (vault_piggypulse_repo_token | default('') | length) > 0

- name: Checkout PiggyPulse repository (authenticated HTTPS)
  ansible.builtin.git:
    repo: "{{ piggypulse_repo_url }}"
    dest: "{{ piggypulse_repo_dest }}"
    version: "{{ piggypulse_repo_version }}"
    update: "{{ piggypulse_repo_update }}"
    accept_hostkey: true
  become_user: "{{ security_deploy_user }}"
  environment:
    GIT_TERMINAL_PROMPT: "0"
    GIT_ASKPASS: "/home/{{ security_deploy_user }}/.git-askpass.sh"
    GIT_USERNAME: "{{ vault_piggypulse_repo_username }}"
    GIT_PASSWORD: "{{ vault_piggypulse_repo_token }}"
  no_log: true
  when:
    - (piggypulse_deploy_mode | default('image_only')) == 'repo'
    - (vault_piggypulse_repo_token | default('') | length) > 0
  notify: Restart piggypulse stack

- name: Checkout PiggyPulse repository (unauthenticated URL)
  ansible.builtin.git:
    repo: "{{ piggypulse_repo_url }}"
    dest: "{{ piggypulse_repo_dest }}"
    version: "{{ piggypulse_repo_version }}"
    update: "{{ piggypulse_repo_update }}"
    accept_hostkey: true
  become_user: "{{ security_deploy_user }}"
  when:
    - (piggypulse_deploy_mode | default('image_only')) == 'repo'
    - (vault_piggypulse_repo_token | default('') | length) == 0
  notify: Restart piggypulse stack

- name: Check production compose directory exists in checked-out repository
  ansible.builtin.stat:
    path: "{{ piggypulse_compose_dir }}"
  register: piggypulse_compose_dir_stat
  when: (piggypulse_deploy_mode | default('image_only')) == 'repo'

- name: Fail when repository revision does not contain deploy/production assets
  ansible.builtin.assert:
    that:
      - piggypulse_compose_dir_stat.stat.exists
      - piggypulse_compose_dir_stat.stat.isdir
    fail_msg: >-
      Expected {{ piggypulse_compose_dir }} to exist after repository checkout,
      but it does not. Ensure piggypulse_repo_version points to a branch/tag/commit
      that includes deploy/production files and that those changes are pushed to origin.
  when: (piggypulse_deploy_mode | default('image_only')) == 'repo'

- name: Check local deployment asset files exist on control node
  ansible.builtin.stat:
    path: "{{ (piggypulse_local_assets_dir | default(playbook_dir ~ '/../deploy/production')) }}/{{ item }}"
  loop:
    - docker-compose.yml
    - Caddyfile
    - .env.example
  register: piggypulse_local_asset_stats
  delegate_to: localhost
  become: false
  when: (piggypulse_deploy_mode | default('image_only')) == 'image_only'

- name: Fail when local deployment assets are missing
  ansible.builtin.assert:
    that:
      - item.stat.exists
      - item.stat.isreg
    fail_msg: >-
      Missing local deployment asset file: {{ item.stat.path }}.
      Ensure piggypulse_local_assets_dir points to deploy/production in this repository.
  loop: "{{ piggypulse_local_asset_stats.results | default([]) }}"
  when: (piggypulse_deploy_mode | default('image_only')) == 'image_only'

- name: Upload deployment assets (image_only mode)
  ansible.builtin.copy:
    src: "{{ (piggypulse_local_assets_dir | default(playbook_dir ~ '/../deploy/production')) }}/{{ item }}"
    dest: "{{ piggypulse_compose_dir }}/{{ item }}"
    owner: "{{ security_deploy_user }}"
    group: "{{ security_deploy_group }}"
    mode: "0640"
  loop:
    - docker-compose.yml
    - Caddyfile
    - .env.example
  when: (piggypulse_deploy_mode | default('image_only')) == 'image_only'
  notify: Restart piggypulse stack

- name: Check required production files exist
  ansible.builtin.stat:
    path: "{{ item }}"
  register: piggypulse_required_files
  loop:
    - "{{ piggypulse_compose_dir }}/docker-compose.yml"
    - "{{ piggypulse_compose_dir }}/Caddyfile"
    - "{{ piggypulse_compose_dir }}/.env.example"

- name: Fail when required production files are missing
  ansible.builtin.assert:
    that:
      - item.stat.exists
      - item.stat.isreg
    fail_msg: "Missing required production deployment file on target host: {{ item.stat.path }}"
  loop: "{{ piggypulse_required_files.results }}"

- name: Assert deploy image vars are populated before starting stack
  ansible.builtin.assert:
    that:
      - (piggypulse_api_image | default('', true) | trim | length) > 0
      - (piggypulse_cron_image | default('', true) | trim | length) > 0
    fail_msg: >-
      Deploy image vars are empty.
      piggypulse_api_image='{{ piggypulse_api_image | default("<undefined>", true) }}'
      piggypulse_cron_image='{{ piggypulse_cron_image | default("<undefined>", true) }}'

- name: Ensure production env file is rendered from vault vars
  ansible.builtin.template:
    src: production.env.j2
    dest: "{{ piggypulse_env_path }}"
    owner: "{{ security_deploy_user }}"
    group: "{{ security_deploy_group }}"
    mode: "0600"
  notify: Restart piggypulse stack

- name: Verify rendered env includes non-empty image refs
  ansible.builtin.shell: |
    set -euo pipefail
    api="$(grep -E '^BUDGET_API_IMAGE=' "{{ piggypulse_env_path }}" | head -n1 | cut -d= -f2-)"
    cron="$(grep -E '^BUDGET_CRON_IMAGE=' "{{ piggypulse_env_path }}" | head -n1 | cut -d= -f2-)"
    echo "BUDGET_API_IMAGE=${api}"
    echo "BUDGET_CRON_IMAGE=${cron}"
    test -n "${api}"
    test -n "${cron}"
  args:
    executable: /bin/bash
  changed_when: false

- name: Ensure GHCR credentials are configured when required
  ansible.builtin.assert:
    that:
      - (vault_piggypulse_ghcr_username | default('') | length) > 0
      - (vault_piggypulse_ghcr_token | default('') | length) > 0
    fail_msg: >-
      GHCR authentication is required. Set vault_piggypulse_ghcr_username and
      vault_piggypulse_ghcr_token in ansible vault.
  when: piggypulse_ghcr_requires_auth | default(false)

- name: Log in to GHCR for production image pulls
  ansible.builtin.shell: |
    set -euo pipefail
    printf '%s' '{{ vault_piggypulse_ghcr_token }}' | docker login ghcr.io \
      --username '{{ vault_piggypulse_ghcr_username }}' \
      --password-stdin
  args:
    executable: /bin/bash
  register: piggypulse_ghcr_login
  changed_when: "'Login Succeeded' in piggypulse_ghcr_login.stdout"
  no_log: true
  when: piggypulse_ghcr_requires_auth | default(false)

- name: Check Docker Compose v2 availability
  ansible.builtin.command:
    cmd: docker compose version
  register: piggypulse_compose_v2_check
  changed_when: false
  failed_when: false

- name: Check docker-compose binary availability
  ansible.builtin.command:
    cmd: docker-compose version
  register: piggypulse_compose_v1_check
  changed_when: false
  failed_when: false

- name: Fail when Docker Compose is not available
  ansible.builtin.assert:
    that:
      - piggypulse_compose_v2_check.rc == 0 or piggypulse_compose_v1_check.rc == 0
    fail_msg: >-
      Neither 'docker compose' nor 'docker-compose' is available on the target host.
      Ensure the docker role installs Docker Compose before running the app role.

- name: Set Docker Compose command facts
  ansible.builtin.set_fact:
    piggypulse_compose_bin: "{{ '/usr/bin/docker' if piggypulse_compose_v2_check.rc == 0 else '/usr/bin/docker-compose' }}"
    piggypulse_compose_subcommand: "{{ 'compose' if piggypulse_compose_v2_check.rc == 0 else '' }}"
    piggypulse_compose_exec: "{{ 'docker compose' if piggypulse_compose_v2_check.rc == 0 else 'docker-compose' }}"

- name: Install PiggyPulse systemd unit
  ansible.builtin.template:
    src: piggypulse-stack.service.j2
    dest: "/etc/systemd/system/{{ piggypulse_systemd_unit }}"
    owner: root
    group: root
    mode: "0644"
  notify:
    - Reload systemd
    - Restart piggypulse stack

- name: Ensure PiggyPulse service is enabled and started
  block:
    - name: Start and enable PiggyPulse systemd unit
      ansible.builtin.systemd:
        name: "{{ piggypulse_systemd_unit }}"
        enabled: true
        state: started
        daemon_reload: true
  rescue:
    - name: Capture systemd status for failed PiggyPulse service
      ansible.builtin.command:
        cmd: "systemctl --no-pager --full status {{ piggypulse_systemd_unit }}"
      register: piggypulse_systemd_status
      changed_when: false
      failed_when: false

    - name: Capture journal logs for failed PiggyPulse service
      ansible.builtin.command:
        cmd: "journalctl -u {{ piggypulse_systemd_unit }} --no-pager -n 200"
      register: piggypulse_systemd_journal
      changed_when: false
      failed_when: false

    - name: Capture compose service status for failed PiggyPulse stack
      ansible.builtin.shell: |
        set -o pipefail
        {{ piggypulse_compose_exec }} ps
      args:
        chdir: "{{ piggypulse_compose_dir }}"
        executable: /bin/bash
      register: piggypulse_compose_ps
      changed_when: false
      failed_when: false

    - name: Capture compose logs for failed PiggyPulse stack
      ansible.builtin.shell: |
        set -o pipefail
        {{ piggypulse_compose_exec }} logs --tail=200 budget db redis cron caddy
      args:
        chdir: "{{ piggypulse_compose_dir }}"
        executable: /bin/bash
      register: piggypulse_compose_logs
      changed_when: false
      failed_when: false

    - name: Fail with PiggyPulse service diagnostics
      ansible.builtin.fail:
        msg: |
          Failed to start {{ piggypulse_systemd_unit }}.
          systemctl status output:
          {{ piggypulse_systemd_status.stdout | default('no status output') }}

          journalctl output:
          {{ piggypulse_systemd_journal.stdout | default('no journal output') }}

          compose ps output:
          {{ piggypulse_compose_ps.stdout | default('no compose ps output') }}

          compose logs output:
          {{ piggypulse_compose_logs.stdout | default('no compose logs output') }}
